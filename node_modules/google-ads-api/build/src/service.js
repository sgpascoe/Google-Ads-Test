"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = exports.FAILURE_KEY = void 0;
var google_gax_1 = require("google-gax");
var google_auth_library_1 = require("google-auth-library");
var protos_1 = require("./protos");
var utils_1 = require("./utils");
var version_1 = require("./version");
// Make sure to update this version number when upgrading
exports.FAILURE_KEY = "google.ads.googleads." + version_1.googleAdsVersion + ".errors.googleadsfailure-bin";
var Service = /** @class */ (function () {
    function Service(clientOptions, customerOptions, hooks) {
        this.clientOptions = clientOptions;
        this.customerOptions = customerOptions;
        this.hooks = hooks !== null && hooks !== void 0 ? hooks : {};
        // @ts-expect-error All fields don't need to be set here
        this.serviceCache = {};
    }
    Object.defineProperty(Service.prototype, "credentials", {
        get: function () {
            return {
                customer_id: this.customerOptions.customer_id,
                login_customer_id: this.customerOptions.login_customer_id,
                linked_customer_id: this.customerOptions.linked_customer_id,
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Service.prototype, "callHeaders", {
        get: function () {
            var headers = {
                "developer-token": this.clientOptions.developer_token,
            };
            if (this.customerOptions.login_customer_id) {
                headers["login-customer-id"] = this.customerOptions.login_customer_id;
            }
            if (this.customerOptions.linked_customer_id) {
                headers["linked-customer-id"] = this.customerOptions.linked_customer_id;
            }
            return headers;
        },
        enumerable: false,
        configurable: true
    });
    Service.prototype.getCredentials = function () {
        var sslCreds = google_gax_1.grpc.credentials.createSsl();
        var authClient = new google_auth_library_1.UserRefreshClient(this.clientOptions.client_id, this.clientOptions.client_secret, this.customerOptions.refresh_token);
        var credentials = google_gax_1.grpc.credentials.combineChannelCredentials(sslCreds, google_gax_1.grpc.credentials.createFromGoogleCredential(authClient));
        return credentials;
    };
    Service.prototype.loadService = function (service) {
        if (this.serviceCache[service]) {
            return this.serviceCache[service];
        }
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        var _a = require("google-ads-node"), _b = service, protoService = _a[_b];
        if (typeof protoService === "undefined") {
            throw new Error("Service \"" + service + "\" could not be found");
        }
        var client = new protoService({
            sslCreds: this.getCredentials(),
        });
        this.serviceCache[service] = client;
        return client;
    };
    Service.prototype.getGoogleAdsError = function (error) {
        var _a;
        // @ts-expect-error No type exists for GA query error
        if (typeof ((_a = error === null || error === void 0 ? void 0 : error.metadata) === null || _a === void 0 ? void 0 : _a.internalRepr.get(exports.FAILURE_KEY)) === "undefined") {
            return error;
        }
        // @ts-expect-error No type exists for GA query error
        var buffer = error.metadata.internalRepr.get(exports.FAILURE_KEY)[0];
        return this.decodeGoogleAdsFailureBuffer(buffer);
    };
    Service.prototype.decodeGoogleAdsFailureBuffer = function (buffer) {
        var googleAdsFailure = protos_1.errors.GoogleAdsFailure.decode(buffer);
        return googleAdsFailure;
    };
    Service.prototype.decodePartialFailureError = function (response) {
        var _a, _b, _c;
        if (typeof ((_a = response) === null || _a === void 0 ? void 0 : _a.partial_failure_error) === "undefined" ||
            !((_b = response) === null || _b === void 0 ? void 0 : _b.partial_failure_error)) {
            return response;
        }
        var details = response.partial_failure_error.details;
        var buffer = (_c = details === null || details === void 0 ? void 0 : details.find(function (d) {
            return d.type_url.includes("errors.GoogleAdsFailure");
        })) === null || _c === void 0 ? void 0 : _c.value;
        if (typeof buffer === "undefined") {
            return response;
        }
        // Update the partial failure field with the decoded error details
        return __assign(__assign({}, response), { partial_failure_error: this.decodeGoogleAdsFailureBuffer(buffer) });
    };
    Service.prototype.buildSearchRequestAndService = function (gaql, options) {
        var service = this.loadService("GoogleAdsServiceClient");
        var request = new protos_1.services.SearchGoogleAdsRequest(__assign({ customer_id: this.customerOptions.customer_id, query: gaql }, options));
        return { service: service, request: request };
    };
    Service.prototype.buildSearchStreamRequestAndService = function (gaql, options) {
        var service = this.loadService("GoogleAdsServiceClient");
        var request = new protos_1.services.SearchGoogleAdsStreamRequest(__assign({ customer_id: this.customerOptions.customer_id, query: gaql }, options));
        return { service: service, request: request };
    };
    Service.prototype.buildMutationRequestAndService = function (mutations, options) {
        var service = this.loadService("GoogleAdsServiceClient");
        var mutateOperations = mutations.map(function (mutation) {
            var _a, _b;
            var _c;
            var opKey = utils_1.toSnakeCase(mutation.entity + "Operation");
            var operation = (_a = {},
                _a[(_c = mutation.operation) !== null && _c !== void 0 ? _c : "create"] = mutation.resource,
                _a);
            if (mutation.operation === "update") {
                // @ts-expect-error Resource operations should have updateMask defined
                operation.update_mask = utils_1.getFieldMask(mutation.resource);
            }
            var mutateOperation = new protos_1.services.MutateOperation((_b = {},
                _b[opKey] = operation,
                _b));
            return mutateOperation;
        });
        var request = new protos_1.services.MutateGoogleAdsRequest(__assign({ customer_id: this.customerOptions.customer_id, mutate_operations: mutateOperations }, options));
        return { service: service, request: request };
    };
    Service.prototype.buildOperations = function (type, entities, message) {
        var ops = entities.map(function (e) {
            var _a;
            var op = (_a = {},
                _a[type] = e,
                _a.operation = type,
                _a);
            if (type === "update") {
                // @ts-expect-error Field required for updates
                op.update_mask = utils_1.getFieldMask(
                // @ts-expect-error Message types have a toObject method
                message.toObject(e, {
                    defaults: false,
                }));
            }
            return op;
        });
        return ops;
    };
    Service.prototype.buildRequest = function (operations, options) {
        var request = __assign({ customer_id: this.customerOptions.customer_id, operations: operations }, options);
        return request;
    };
    return Service;
}());
exports.Service = Service;
